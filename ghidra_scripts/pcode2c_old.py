# @category: PCode2C
# @toolbar scripts/C_Logo.png
# @menupath Pcode2C.oldrun

# Import Ghidra modules
from ghidra.app.decompiler import DecompInterface
from ghidra.program.model.pcode import PcodeOp
from ghidra.util.task import ConsoleTaskMonitor
import sys
from ghidra.program.model.block import BasicBlockModel
from ghidra.util.task import ConsoleTaskMonitor
from ghidra.program.model.symbol import SymbolUtilities


def interp_varnode(varnode):
    size = varnode.getSize()
    if size == 1:
        typ = "int8_t"
    elif size == 2:
        typ = "int16_t"
    elif size == 4:
        typ = "int32_t"
    elif size == 8:
        typ = "int64_t"
    else:
        assert False, "unrecognized size %d" % size
    space = varnode.getSpace()
    offset = varnode.getOffset()
    size = str(varnode.getSize())
    # check if in constant map
    # also probably reg map
    # print(dir(space))
    if varnode.isConstant():
        return "&({}){{{}}}".format(typ, hex(varnode.getOffset())), size
    elif varnode.isRegister():
        reg = currentProgram.getRegister(varnode.getAddress(), varnode.getSize())
        if reg != None:
            name = reg.getName()
        return "reg + 0x{:x} /* {} */".format(varnode.getOffset(), name), size
    elif varnode.isUnique():
        return "unique + 0x{:x}".format(varnode.getOffset()), size
    elif varnode.isAddress():
        return "ram + 0x{:x}".format(varnode.getOffset()), size
    # addrspace = currentProgram.getAddressFactory().getAddressSpace(varnode.getOffset())
    # name += addrspace.getName()
    else:
        assert False, "unrecognized varnode type {}".format(varnode)


def pcode2c(pcode):
    # print(dir(pcode))
    numInputs = pcode.getNumInputs()
    args = list(pcode.getInputs())
    output = pcode.getOutput()
    if output != None:
        args = [output] + args
    args = map(interp_varnode, args)
    args = sum(args, ())
    args = ", ".join(args)
    return "\t\t\t{}({}); // {}".format(pcode.getMnemonic(), args, pcode)


def register_and_names():
    output = []
    currentProgram = getCurrentProgram()
    ctx = currentProgram.getProgramContext()
    reglist = ctx.getRegisters()
    # https://ghidra.re/ghidra_docs/api/ghidra/program/model/lang/Register.html
    for reg in reglist:
        print(reg)
        print(reg.getName())
        print(reg.getAddress())
        print(reg.getMinimumByteSize())
        print(reg.getBaseRegister())
        output.append(
            "#define {} 0x{:x}".format(reg.getName(), reg.getAddress().getOffset())
        )
    symtab = currentProgram.getSymbolTable()
    # https://ghidra.re/ghidra_docs/api/ghidra/program/model/symbol/SymbolTable.html
    # https://ghidra.re/ghidra_docs/api/ghidra/program/model/symbol/SymbolUtilities.html
    symbols = symtab.getAllSymbols(True)
    for symbol in symbols:
        print(symbol)
        print(symbol.getName())
        print(symbol.getAddress())
        print(symbol.getSymbolType())
    return "\n".join(output)
    # symtab.getGlobalSymbols()
    # hmm. relocations


def dump_raw_pcode(func):
    func_body = func.getBody()
    listing = currentProgram.getListing()
    opiter = listing.getInstructions(func_body, True)
    output = []
    output.append("/* AUTOGENERATED. DO NOT EDIT. */")
    output.append('#include "_pcode.h"')
    output.append(
        "void pcode2c_{}(CPUState *state, size_t breakpoint){{".format(func.getName())
    )
    output.append(
        "\tuint8_t* reg = state->reg; uint8_t* unique = state->unique; uint8_t* ram = state->ram;"
    )
    output.append("\tfor(;;){")
    output.append("\tswitch(state->pc) {")
    while opiter.hasNext():
        op = opiter.next()
        output.append("\t\tcase 0x{}:".format(op.getAddress()))
        output.append('\t\t\tINSN(0x{},"{}")'.format(op.getAddress(), op))
        raw_pcode = op.getPcode()
        for entry in raw_pcode:
            output.append(pcode2c(entry))
    output.append("\t\tdefault: assert(0);")
    output.append("}}}")
    return "\n".join(output)


import os
import shutil

if __name__ == "__main__":
    # Get current program and function
    currentProgram = getCurrentProgram()
    symbolTable = currentProgram.getSymbolTable()
    # Get function name from command line arguments

    args = getScriptArgs()
    print(args)
    if len(args) > 0:
        funcName = args[0]  # sys.argv[1]
        func = getGlobalFunctions(funcName)[0]
    else:
        func = getFunctionContaining(currentAddress)

    output = dump_raw_pcode(func)
    print(output)
    # filename = askFile("Save decompilation to file", "Save")
    dir = askDirectory("Save decompilation to file", "Save")
    # with open("/home/philip/Documents/python/pcode2c/decomp.c", "w") as f:
    # append to path instead
    with open(os.path.join(dir.toString(), "decomp.c"), "w") as f:
        # with open(filename.toString(), "w") as f:
        f.write(output)
    with open(os.path.join(dir.toString(), "arch.h"), "w") as f:
        f.write(register_and_names())
    # copy pcode.h from script directory to working directory
    this_dir = os.path.join(os.path.dirname(os.path.realpath(__file__)), "templates")
    for filename in ["_pcode.h", "verify_template.c", "Makefile"]:
        shutil.copy(
            os.path.join(this_dir, filename),
            dir.toString(),
        )
