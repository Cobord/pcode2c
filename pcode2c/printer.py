import pypcode


def is_branch(op: pypcode.OpCode):
    return op in (
        pypcode.OpCode.BRANCH,
        pypcode.OpCode.CBRANCH,
        pypcode.OpCode.BRANCHIND,
        pypcode.OpCode.CALL,
        pypcode.OpCode.CALLIND,
        pypcode.OpCode.RETURN,
    )


def fmt_varnode(varnode: pypcode.Varnode):
    return f"{varnode.space.name} + {varnode.offset} /* {varnode.getRegisterName()} */, {varnode.size}"


def fmt_insn(op: pypcode.PcodeOp):
    args = [fmt_varnode(op.output)] if op.output else []
    args.extend(fmt_varnode(varnode) for varnode in op.inputs)
    args = ", ".join(args)
    opcode = str(op.opcode).replace("pypcode.pypcode_native.OpCode.", "")
    if is_branch(op.opcode):
        return f"{opcode}({args});break;"
    else:
        return f"{opcode}({args});"


"""
def dump_insns(insns):
    output = []
    for addr, ins in insns.items():
        entry = insns[addr]
        output.append(
           
        )
    return "\n".join(output)
"""


def dump_raw_pcode(funcname, body):
    return f"""
/* AUTOGENERATED. DO NOT EDIT. */
#include "_pcode.h"
void pcode2c_{funcname}(CPUState *state, size_t breakpoint){{".format(func.getName())
    uint8_t* reg = state->reg; 
    uint8_t* unique = state->unique; 
    uint8_t* ram = state->ram;
    for(;;){{
    switch(state->pc) {{
    {body}
        default: assert(0);
    }}}}}}
"""


def fmt_arch_header(ctx):
    output = []
    for reg, vnode in ctx.registers.items():
        output.append(f"#define {reg} 0x{vnode.offset:x}")
    return "\n".join(output)
