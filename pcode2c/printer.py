import pypcode


def fmt_arch_header(langid):
    ctx = Context(langid)
    output = []
    for reg, vnode in ctx.registers.items():
        output.append(f"#define {reg} 0x{vnode.offset:x}")
    return output


def fmt_symbol_header(elf):
    # Get the symbol table
    output = []
    symtab = elffile.get_section_by_name(".symtab")
    for symbol in symtab.iter_symbols():
        output.append(f'#define {symbol.name} {symbol["st_value"]})')
    return output


# import importlib
# with importlib.resources("pcode2c.include", "_pcode2c.h") as f:
#    pcode2c_include = f.read()


def is_branch(op: pypcode.OpCode):
    return op in (
        pypcode.OpCode.BRANCH,
        pypcode.OpCode.CBRANCH,
        pypcode.OpCode.BRANCHIND,
        pypcode.OpCode.CALL,
        pypcode.OpCode.CALLIND,
        pypcode.OpCode.RETURN,
    )


def fmt_varnode(varnode: pypcode.Varnode):
    if varnode.space.name == "const":
        return (
            "(uint8_t *)&(long unsigned int){"
            + hex(varnode.offset)
            + "ul}, "
            + hex(varnode.size)
            + "ul"
        )

    regname = varnode.getRegisterName()
    if regname != "":
        regname = f" /* {regname} */"
    return f"{varnode.space.name}_space + {hex(varnode.offset)}ul{regname}, {varnode.size}ul"


def fmt_varnode_separate_space(varnode: pypcode.Varnode):
    if varnode.space.name == "const":
        return (
            "0, (uint8_t *)&(long unsigned int){"
            + hex(varnode.offset)
            + "ul}, "
            + hex(varnode.size)
            + "ul"
        )

    regname = varnode.getRegisterName()
    if regname != "":
        regname = f" /* {regname} */"
    return f"{varnode.space.name}_space, {hex(varnode.offset)}ul{regname}, {varnode.size}ul"


def fmt_insn(op: pypcode.PcodeOp):
    args = [fmt_varnode(op.output)] if op.output else []
    args.extend(fmt_varnode(varnode) for varnode in op.inputs)
    args = ", ".join(args)
    opcode = str(op.opcode).replace("pypcode.pypcode_native.OpCode.", "")
    if op.opcode == pypcode.OpCode.BRANCH:
        return f"BRANCH_GOTO_TEMPFIX({fmt_varnode_separate_space(op.inputs[0])})"
    elif op.opcode == pypcode.OpCode.CBRANCH:
        args = (
            fmt_varnode_separate_space(op.inputs[0])
            + ", "
            + fmt_varnode_separate_space(op.inputs[1])
        )
        return f"CBRANCH_GOTO_TEMPFIX({args})"
    else:
        return f"{opcode}({args});"


header = """\
/* AUTOGENERATED. DO NOT EDIT. */
#include "_pcode.h"
void pcode2c(CPUState *state, size_t breakpoint){
    uint8_t* register_space = state->reg; 
    uint8_t* unique_space = state->unique; 
    uint8_t* ram_space = state->ram;
    uint8_t* ram = ram_space; // TODO: remove this
    for(;;){
    switch(state->pc){"""

footer = """\
        default: assert(state->pc != -1); // Unexpected PC value
}}}"""


from elftools.elf.elffile import ELFFile
from pypcode import Context, PcodePrettyPrinter


def pcode2c(filename, langid):
    output = []
    with open(filename, "rb") as file:
        elffile = ELFFile(file)

        # Get the symbol table
        # if args.function is not None:
        #    symtab = elffile.get_section_by_name(".symtab")
        # Search for the function in the symbol table
        #    for symbol in symtab.iter_symbols():
        #        if symbol.name == args.function:
        #            fun_addr = symbol["st_value"]

        # Iterate over sections and find the .text section
        for section in elffile.iter_sections():
            if section.name == ".text":
                offset = section.header["sh_offset"]
                size = section.header["sh_size"]
                file.seek(offset)
                code = file.read(size)
                break
        if len(code) == 0:
            raise ValueError("No .text section found")

    ctx = Context(langid)
    dx = ctx.disassemble(code)
    insns = {insn.addr.offset: insn for insn in dx.instructions}
    # print(fmt_arch_header(ctx))
    res = ctx.translate(code)
    output.append(header)
    for op in res.ops:
        if op.opcode == pypcode.OpCode.IMARK:
            assert len(op.inputs) == 1
            addr = op.inputs[0].offset
            ins = insns[addr]
            output.append(
                f"""\
        case 0x{addr:x}:
        L_0x{addr:x}ul:
            INSN(0x{addr:x}ul,"{ins.addr.offset:#x}: {ins.mnem} {ins.body}")"""
            )
        else:
            # print("//", PcodePrettyPrinter.fmt_op(op))
            output.append("            " + fmt_insn(op))
            if op.opcode == pypcode.OpCode.RETURN:
                output.append("            return;")
    output.append(footer)
    return output


def single(precond, postcond, equality=False):
    return f"""\
int main(){{
    CPUState state;
    init_state(&state);
    __CPROVER_assume({precond});
    pcode2c(&state, -1);
    __CPROVER_assert({postcond});
}}"""


def comparative(precond, postcond, equality=False):
    return f"""\
int main(){{
    CPUState state_orig, state_mod;
    __CPROVER_assume({precond});
    pcode2c_orig(&state_orig, -1);
    pcode2c_mod(&state_mod, -1);
    __CPROVER_assert({postcond}, "Postcondition");
}}"""
